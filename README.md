# Data Structures and Algoritmhs

This repository will contain implementations and explanations over several algorithms and data structures, working as a study guide of these topics.

# Big O - How efficient is your algorithm?

It's the measure for how many operations an algorithm has to execute when given an input of size N.

The classifications below go from best (O(1)) to worst (O(n!)).

## O(1) - constant

The best classification possible. It doesn't matter the size of the input, our algorithm will always do the same number of operations, it will be **_constant_**.

## O(log n) - logarithmic

## O(n) - linear

As our input increases, the number of operations necessary to run to each element will be the same number of elements. It will increase linearly.

## O(n.log n) - superlinear

## O($n^2$) - polynomial

## O($2^n$) - exponential

## O(n!) - factorial

# Tips to Help Us Calculate Big O

## Tip 1: Worst Case

We optimize algorithms by fixing their worse case scenarios. By acting on this floor limitation we assure that even if in the worst case the algorithm still has a good Big O classification, we will have the same or better results in the average and best scenarios.

## Tip 2: Remove Contants

## Tip 3: Different terms for inputs

## Tip 4: Drop Non Dominants
